SET(STM32C11_LINKER_SCRIPT_TEXT
"MEMORY\n"
"{\n"
"	FLASH	(rx)  : ORIGIN = ${STM32_FLASH_ORIGIN}, LENGTH = ${STM32_FLASH_SIZE}\n"
"  	RAM 	(rwx) : ORIGIN = ${STM32_RAM_ORIGIN}, LENGTH = ${STM32_RAM_SIZE}\n"
"}\n"
"\n"
"/* Config Libraries */\n"
"GROUP(libgcc.a libc.a libm.a libnosys.a)\n"
"\n"
"ENTRY(resetHandler)\n"
"\n"
"SECTIONS\n"
"{\n"
"	.text :\n"
"	{\n"
"		KEEP(*(.exception_vector))\n"
"		KEEP(*(.interrupt_vector))\n"
"		*(.text*)\n"
"\n"
"		KEEP(*(.init))\n"
"		KEEP(*(.fini))\n"
"\n"
"		/* .ctors */\n"
"		*crtbegin.o(.ctors)\n"
"		*crtbegin?.o(.ctors)\n"
"		*(EXCLUDE_FILE(*crtend?.o *crtend.o) .ctors)\n"
"		*(SORT(.ctors.*))\n"
"		*(.ctors)\n"
"\n"
"		/* .dtors */\n"
"		*crtbegin.o(.dtors)\n"
"		*crtbegin?.o(.dtors)\n"
"		*(EXCLUDE_FILE(*crtend?.o *crtend.o) .dtors)\n"
"		*(SORT(.dtors.*))\n"
"		*(.dtors)\n"
"\n"
"		*(.rodata*)\n"
"\n"
"		KEEP(*(.eh_frame*))\n"
"	} > FLASH\n"
"\n"
"	.ARM.extab : \n"
"	{\n"
"		*(.ARM.extab* .gnu.linkonce.armextab.*)\n"
"	} > FLASH\n"
"\n"
"	__exidx_start = .\;\n"
"	.ARM.exidx :\n"
"	{\n"
"		*(.ARM.exidx* .gnu.linkonce.armexidx.*)\n"
"	} > FLASH\n"
"	__exidx_end = .\;\n"
"\n"
"	__etext = .\;\n"
"		\n"
"	.data : AT (__etext)\n"
"	{\n"
"		__data_start__ = .\;\n"
"		*(vtable)\n"
"		*(.data*)\n"
"\n"
"		. = ALIGN(4)\;\n"
"		/* preinit data */\n"
"		PROVIDE_HIDDEN (__preinit_array_start = .)\;\n"
"		KEEP(*(.preinit_array))\n"
"		PROVIDE_HIDDEN (__preinit_array_end = .)\;\n"
"\n"
"		. = ALIGN(4)\;\n"
"		/* init data */\n"
"		PROVIDE_HIDDEN (__init_array_start = .)\;\n"
"		KEEP(*(SORT(.init_array.*)))\n"
"		KEEP(*(.init_array))\n"
"		PROVIDE_HIDDEN (__init_array_end = .)\;\n"
"\n"
"\n"
"		. = ALIGN(4)\;\n"
"		/* finit data */\n"
"		PROVIDE_HIDDEN (__fini_array_start = .)\;\n"
"		KEEP(*(SORT(.fini_array.*)))\n"
"		KEEP(*(.fini_array))\n"
"		PROVIDE_HIDDEN (__fini_array_end = .)\;\n"
"\n"
"		. = ALIGN(4)\;\n"
"		/* All data end */\n"
"		__data_end__ = .\;\n"
"\n"
"	} > RAM\n"
"\n"
"	.bss :\n"
"	{\n"
"		__bss_start__ = .\;\n"
"		*(.bss*)\n"
"		*(COMMON)\n"
"		__bss_end__ = .\;\n"
"	} > RAM\n"
"	\n"
"	.heap :\n"
"	{\n"
"		__end__ = .\;\n"
"		end = __end__\;\n"
"		*(.heap*)\n"
"		__HeapLimit = .\;\n"
"	} > RAM\n"
"\n"
"	/* .stack_dummy section doesn't contains any symbols. It is only\n"
"	 * used for linker to calculate size of stack sections, and assign\n"
"	 * values to stack symbols later */\n"
"	.stack_dummy :\n"
"	{\n"
"		*(.stack*)\n"
"	} > RAM\n"
"\n"
"	/* Set stack top to end of RAM, and stack limit move down by\n"
"	 * size of stack_dummy section */\n"
"	__StackTop = ORIGIN(RAM) + LENGTH(RAM)\;\n"
"	__StackLimit = __StackTop - SIZEOF(.stack_dummy)\;\n"
"	PROVIDE(__stack = __StackTop)\;\n"
"	\n"
"	/* Check if data + heap + stack exceeds RAM limit */\n"
"	ASSERT(__StackLimit >= __HeapLimit, \"region RAM overflowed with stack\")\n"
"}\n"
)